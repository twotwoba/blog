---
title: 'å›¾'
date: '2022-10-15'
tags: ['data structure', 'algorithm']
draft: false
summary: 'æµ…å­¦ä¸€ä¸‹å›¾ğŸ°'
images: []
---

## å›¾è®ºåŸºç¡€

### é‚»æ¥è¡¨&é‚»æ¥çŸ©é˜µ

å‡ºåº¦ã€å…¥åº¦ç­‰åŸºç¡€æ¦‚å¿µè‡ªè¡Œç™¾åº¦.

<img src="https://cdn.jsdelivr.net/gh/yokiizx/picgo@main/img/202404031402924.png" className="w-[300px]" />

ä¸Šé¢è¿™å¹…æœ‰å‘å›¾ï¼Œåˆ†åˆ«ç”¨é‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µå®ç°å¦‚ä¸‹ï¼š

```ts
// é‚»æ¥è¡¨ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç”¨ hashmap æ¥å®ç°
const graph: Array<number[]> = [[1, 3, 4], [2, 3, 4], [3], [4], []]
// é‚»æ¥çŸ©é˜µï¼Œå½“ç„¶å…ƒç´ ä¸ä»…ä»…åªèƒ½ä¸º Boolean å€¼
const graph: Array<boolean[]> = [
    [false, true, false, true, true],
    [false, false, true, true, true],
    [false, false, false, true, false],
    [false, false, false, false, true],
    [false, false, false, false, false]
]
```

- é‚»æ¥è¡¨ï¼šå ç”¨ç©ºé—´å°‘ï¼›åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸é‚»ï¼Œéœ€è¦éå†æ‰€æœ‰ç›¸é‚»çš„èŠ‚ç‚¹
- é‚»æ¥çŸ©é˜µï¼šå­˜åœ¨å¾ˆå¤šç©ºæ´ï¼Œå ç”¨ç©ºé—´å¤§ï¼›åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸é‚»ç®€å•ï¼Œè·å– `matrix[i][j]` çš„å€¼å³å¯

### å›¾çš„éå†

å›¾çš„éå†ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å›¾å¯èƒ½æœ‰ç¯ï¼š

1. å¿…é¡»è¦æœ‰ `visited` å˜é‡æ¥é˜²æ­¢èµ°å…¥æ­»å¾ªç¯
2. éå†è¿‡ç¨‹ä¸­å¯ä»¥ä½¿ç”¨ `onPath` å˜é‡åˆ¤æ–­å½“æ—¶çš„è·¯å¾„æ˜¯å¦æˆç¯ï¼ˆç±»æ¯”è´ªåƒè›‡è›‡èº«ï¼‰

```js
/** visited ç±»ä¼¼è´ªåƒè›‡èµ°è¿‡çš„æ‰€æœ‰è·¯å¾„ï¼›onPath ç±»ä¼¼è®¾è›‡èº« */
// è®°å½•æ‰€æœ‰éå†è¿‡çš„èŠ‚ç‚¹
const visited = []
// è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
const onPath = []

/* å›¾éå†æ¡†æ¶ DFS */
function traverse(graph, s) {
    if (visited[s]) return
    // ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå†
    visited[s] = true
    // åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š
    onPath[s] = true
    for (const neighbor of graph.neighbors(s)) {
        traverse(graph, neighbor)
    }
    // æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„
    onPath[s] = false
}
```

> - å›æº¯åšé€‰æ‹©å’Œæ’¤é”€é€‰æ‹©æ˜¯åœ¨ for å¾ªç¯å†…ï¼Œå¯¹åº”é€‰æ‹©ã€æ’¤é”€é€‰æ‹©çš„å¯¹è±¡æ˜¯ã€Œæ ‘æã€
> - DFS åšé€‰æ‹©å’Œæ’¤é”€é€‰æ‹©æ˜¯åœ¨ for å¾ªç¯å¤–ï¼Œå¯¹åº”é€‰æ‹©ã€æ’¤é”€é€‰æ‹©çš„å¯¹è±¡æ˜¯ã€ŒèŠ‚ç‚¹ã€
>
> æŠ½è±¡å‡ºã€Œæ ‘æï¼ŒèŠ‚ç‚¹ã€æ˜¯ä¸ºäº†æ›´åŠ å½¢è±¡çš„ç†è§£ï¼Œå…¶å®æ”¾åœ¨ for å¾ªç¯å¤–å°±æ˜¯ä¸ºäº†ä¸è¦æ¼æ‰ ã€Œåˆå§‹èŠ‚ç‚¹ã€ã€‚å…·ä½“çš„è¯·å‚çœ‹ [æš´åŠ›é€’å½’-DFS&å›æº¯](../dfs-track-back) è¿™ç¯‡æ–‡ç« ã€‚

#### lc.797 æ‰€æœ‰å¯èƒ½çš„è·¯å¾„

```js
var allPathsSourceTarget = function (graph) {
    // æœ‰å‘æ— ç¯å›¾, graph çš„ index è‡ªèº«å³ä¸º node; graph[index] ä¸ºé‚»å±…
    let res = []
    const onPath = []
    const dfs = (node) => {
        onPath.push(node)
        if (node === graph.length - 1) {
            res.push([...onPath])
            /** å› ä¸ºæ— ç¯ï¼Œæ‰€ä»¥ä¸ç”¨ returnï¼›å¦‚æœ return åŒæ—¶éœ€è¦ç»´æŠ¤ onPath */
            // onPath.pop()
            // return
        }
        for (let i = 0; i < graph[node].length; ++i) {
            dfs(graph[node][i])
        }
        onPath.pop()
    }
    dfs(0)
    return res
}
```

## ç»å…¸é—®é¢˜

### æœ‰å‘å›¾ç¯æ£€æµ‹&æ‹“æ‰‘æ’åº

å¯¹äºæœ‰ã€Œä¾èµ–å…³ç³»ã€çš„é—®é¢˜ï¼Œä¸€èˆ¬å¯ä»¥æŠ½è±¡ä¸ºä¸€å‰¯æœ‰å‘å›¾ï¼Œæ£€æµ‹æ˜¯å¦æœ‰å¾ªç¯ä¾èµ–å³å¯ã€‚

#### lc.207 è¯¾ç¨‹è¡¨

ç”¨é‚»æ¥è¡¨çš„å½¢å¼æ¥æŠ½è±¡æœ¬é¢˜çš„æœ‰å‘å›¾ã€‚

- dfs æ£€æµ‹ç¯ï¼Œå€ŸåŠ©å›¾éå†ä¸­çš„ onPath æ•°ç»„ï¼Œåˆ¤æ–­è›‡èº«æ˜¯å¦ç›¸æ’å³å¯

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function (numCourses, prerequisites) {
    // å…ˆæ„å›¾
    const graph = Array.from(Array(numCourses), () => [])
    for (let i = 0; i < prerequisites.length; ++i) {
        const [to, from] = prerequisites[i]
        graph[from].push(to) // from -> to
    }
    // å†åˆ¤æ–­æ˜¯å¦æœ‰ç¯
    const onPath = [] // è®°å½•éå†è¿‡ç¨‹
    const visited = [] // é˜²æ­¢è¿›å…¥æ­»å¾ªç¯
    let hasCycle = false
    const dfs = (node) => {
        // è›‡èº«æˆç¯
        if (onPath.indexOf(node) > -1) {
            hasCycle = true
            return
        }
        if (visited.indexOf(node) > -1 || hasCycle) return
        onPath.push(node)
        visited.push(node)
        for (const neighbor of graph[node]) {
            dfs(neighbor)
        }
        onPath.pop()
    }

    for (let i = 0; i < numCourses; ++i) {
        dfs(i)
    }
    return !hasCycle
}
```

---

- bfs æ£€æµ‹ç¯ï¼Œéœ€è¦å€ŸåŠ©å…¥åº¦æ•°ç»„ï¼Œå½“æŸä¸ªèŠ‚ç‚¹å…¥åº¦ä¸º 0 çš„æ—¶å€™ä»£è¡¨å®ƒæˆä¸ºäº†å¤´äº†ï¼ŒåŠ å…¥é˜Ÿåˆ—

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function (numCourses, prerequisites) {
  // å…ˆæ„å›¾ + æ„å»ºå…¥åº¦æ•°ç»„
  const graph = Array.from(Array(numCourses), () => [])
  const indegree = Array(numCourses).fill(0)
  for (let i = 0; i < prerequisites.length; ++i) {
    const [to, from] = prerequisites[i]
    graph[from].push(to) // from -> to
    indegree[to]++
  }
  // å¯»æ‰¾å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œç„¶åå¼€å§‹ bfs éå†
  const queue = []
  for (let i = 0; i < numCourses; ++i) {
    indegree[i] === 0 && queue.push(i)
  }
  let visitedCount = 0
  while (queue.length) {
    // è¿™é“é¢˜ä¸ç”¨å‘å››å‘¨åˆ†æ•£ï¼Œè€Œæ˜¯å»æ“ä½œå…¥åº¦æ•°ç»„
    visitedCount++
    const node = queue.shift()
    const indegreeOfNode = graph[node]
    for (let i = 0; i < indegreeOfNode.length; ++i) {
      indegree[indegreeOfNode[i]]--
      if (indegree[indegreeOfNode[i]] === 0) {
        queue.push(indegreeOfNode[i])
      }
    }
  }

  // å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«éå†è¿‡ï¼Œè¯´æ˜ä¸æˆç¯
  // 1. å¦‚æœå°±æ˜¯ä¸€ä¸ªå®Œæ•´ç¯ï¼Œé‚£ä¹ˆæ²¡æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹ä¸ä¼šè¿›å…¥éå†
  // 2. å¦‚æœæ˜¯å›¾ä¸­æœ‰ä¸€éƒ¨åˆ†ä¸ºç¯ï¼Œé‚£ä¹ˆç¯èµ·ç‚¹çš„å…¥åº¦å§‹ç»ˆä¸ä¼šä¸º 0
  return visitedCount === numCourses
```

#### lc.210 è¯¾ç¨‹è¡¨ II

æ­¤é¢˜ç›¸æ¯”ä¸Šä¸€é¢˜ï¼Œæ— éå°±æ˜¯**éœ€è¦è®°å½•ä¸‹æ¥å®Œæ•´çš„ä¾èµ–å›¾**ï¼Œé‚£ä¹ˆå°±å¾—äº†è§£ä¸‹ ã€Œæ‹“æ‰‘æ’åºäº†ã€ï¼š[æ‹“æ‰‘æ’åº-ç»´åŸºç™¾ç§‘](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)

> ç›´è§‚ç‚¹è®²ï¼Œå°±æ˜¯æŠŠä¸€å¹…æœ‰å‘å›¾æ‹‰å¹³åï¼Œæ¯æ¡è¾¹çš„æŒ‡å‘ç›¸åŒã€‚

- dfs æ‹“æ‰‘ï¼š åœ¨ä¸Šä¸€é¢˜ dfs æ£€æµ‹ç¯çš„åç»­ä½ç½®æ”¶é›†èŠ‚ç‚¹ä¸ºä¸€ä¸ªé›†åˆï¼Œå¯¹è¿™ä¸ªé›†åˆé€†åºå³ä¸ºæ‹“æ‰‘æ’åºçš„ä¸€ä¸ªç»“æœï¼›æˆ–è€…åœ¨æ„å›¾æ—¶ï¼Œ`graph[to].push(from)`ï¼Œæœ€åå°±ä¸ç”¨é€†åºäº†

// 1. è¦å®ç°æ‹“æ‰‘æ’åºï¼Œå›¾ä¸èƒ½æœ‰ç¯ï¼Œå› ä¸ºè¦ç¡®ä¿æ¯æ¡è¾¹ u åœ¨ v ä¹‹å‰
// 2. æœ‰å‘æ— ç¯å›¾çš„æ‹“æ‰‘æ’åºè‡³å°‘æœ‰ä¸€ç§
// 3. dfs å’Œ bfs éƒ½èƒ½å®ç°æ‹“æ‰‘æ’åº
// 3.1 DFS ç®—æ³•åˆ©ç”¨é€†ååºéå†ï¼ˆæˆ–è€…åˆ©ç”¨é€†é‚»æ¥è¡¨ï¼‰è¿›è¡Œæ‹“æ‰‘æ’3.2 åºï¼ŒBFS å€ŸåŠ© indegree(å…¥åº¦) æ•°ç»„ä¹Ÿèƒ½å®ç°ã€‚

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function (numCourses, prerequisites) {
    const graph = Array.from(Array(numCourses), () => [])
    for (let i = 0; i < prerequisites.length; ++i) {
        const [to, from] = prerequisites[i]
        graph[to].push(from) // æ³¨æ„è¿™é‡Œï¼
    }
    let res = []
    let hasCycle = false
    const visited = []
    const onPath = []
    const dfs = (node) => {
        if (onPath.indexOf(node) > -1) {
            hasCycle = true
            return
        }
        if (visited.indexOf(node) > -1 || hasCycle) return
        onPath.push(node)
        visited.push(node)
        for (const neighbor of graph[node]) {
            dfs(neighbor)
        }
        res.push(node)
        onPath.pop()
    }
    for (let i = 0; i < numCourses; ++i) {
        dfs(i)
    }
    if (hasCycle) return []
    return res
}
```

---

- bfs æ‹“æ‰‘ï¼šåœ¨ä¸Šä¸€é¢˜ bfs æ£€æµ‹ç¯çš„åŸºç¡€ä¸Šï¼Œå¾ˆå®¹æ˜“ç†è§£å‡ºé˜Ÿçš„é¡ºåºå°±æ˜¯æ‹“æ‰‘æ’åºçš„ç»“æœã€‚

```js
var findOrder = function (numCourses, prerequisites) {
    // å…ˆæ„å›¾ + æ„å»ºå…¥åº¦æ•°ç»„
    const graph = Array.from(Array(numCourses), () => [])
    const indegree = Array(numCourses).fill(0)
    for (let i = 0; i < prerequisites.length; ++i) {
        const [to, from] = prerequisites[i]
        graph[from].push(to) // from -> to
        indegree[to]++
    }
    // å¯»æ‰¾å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œç„¶åå¼€å§‹ bfs éå†
    const queue = []
    for (let i = 0; i < numCourses; ++i) {
        indegree[i] === 0 && queue.push(i)
    }
    let visitedCount = 0
    const res = []
    while (queue.length) {
        // è¿™é“é¢˜ä¸ç”¨å‘å››å‘¨åˆ†æ•£ï¼Œè€Œæ˜¯å»æ“ä½œå…¥åº¦æ•°ç»„
        visitedCount++
        const node = queue.shift()
        res.push(node)
        const indegreeOfNode = graph[node]
        for (let i = 0; i < indegreeOfNode.length; ++i) {
            indegree[indegreeOfNode[i]]--
            if (indegree[indegreeOfNode[i]] === 0) {
                queue.push(indegreeOfNode[i])
            }
        }
    }
    if (visitedCount !== numCourses) return []
    return res
}
```

ä»æ£€æµ‹ç¯çš„è§’åº¦æ¥è¯´ï¼šã€Œæ‹“æ‰‘æ’åºã€å¯ä»¥åˆ¤æ–­-æœ‰å‘å›¾-æ˜¯å¦æœ‰ç¯ï¼Œã€Œå¹¶æŸ¥é›†ã€å¯ä»¥åˆ¤æ–­-æ— å‘å›¾-æ˜¯å¦æœ‰ç¯

### å¹¶æŸ¥é›†

> å‚è€ƒäº†æ­¤ç¯‡æ–‡ç«  https://oi-wiki.org/ds/dsu/

å¹¶æŸ¥é›†é€šå¸¸ç”¨æ¥è§£å†³ã€Œè¿é€šæ€§ã€é—®é¢˜ --- ä¸»è¦åŠŸèƒ½å¤§ç™½è¯å°±æ˜¯ï¼š

1. Union - å°†ä¸¤ä¸ªå…ƒç´ åˆå¹¶åˆ°ä¸€ä¸ªé›†åˆä¸­
2. Find - åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆé‡Œ

å¦‚ä½•è®©ä¸¤ä¸ªå…ƒç´ è¿é€šå‘¢ï¼Ÿ`father[a] = b; father[b] = c`ï¼Œè¿™æ ·å°±å¥½äº†ï¼Œé€šè¿‡ a å¯ä»¥æ‰¾åˆ° bï¼Œé€šè¿‡ b å¯ä»¥æ‰¾åˆ° cã€‚

#### åŸºç¡€

å¹¶æŸ¥é›†çš„å®ç°ä¸ºä¸€ä¸ªæ£®æ—ï¼ˆå¤šä¸ªæ ‘ï¼‰ï¼Œæ¯ä¸ªæ ‘è¡¨ç¤ºä¸€ä¸ªé›†åˆï¼Œæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªå…ƒç´ ã€‚

```js
/** disjoint sets union */
class Dsu {
    // åˆå§‹åŒ–ï¼šæ¯ä¸ªå…ƒç´ ä½äºä¸€ä¸ªã€Œå•ç‹¬çš„é›†åˆã€ï¼Œ--æ ¹èŠ‚ç‚¹ä¸ºè‡ªèº«--
    constructor(size) {
        this.father = Array.from(Array(size), (_, index) => index)
    }
    // æŠŠé›†åˆ u, v åˆå¹¶åˆ°ä¸€ä¸ªé›†åˆï¼Œåˆå¹¶çš„æ˜¯æ ¹~
    join(u, v) {
        u = find(u) // å¯»æ ¹
        v = find(v) // å¯»æ ¹
        if (u === v) return
        this.father[v] = u // è¯·æ³¨æ„ï¼ï¼šè¿™é‡Œè¿é€šçš„æ˜¯å…¥å‚ uï¼Œv çš„æ ¹
    }
    // å‘ä¸Šå¯»æ ¹
    find(u) {
        if (u === this.father[u]) return u // è‡ªèº«
        // return find(this.father[u])
        /**
         * è·¯å¾„å‹ç¼©ï¼š å¦‚æœæ¯æ¬¡éƒ½å¦‚ä¸Šè¡Œé‚£æ ·é€’å½’å¯»æ‰¾ä¸Šçº§ï¼Œæ¯”è¾ƒæµªè´¹æ—¶é—´
         * è·¯å¾„å‹ç¼©å°±æ˜¯æŠŠèŠ‚ç‚¹ç›´æ¥æ¥åˆ°æ ¹èŠ‚ç‚¹ä¸Šï¼Œè€Œè¿™ä¸€æ­¥æ“ä½œå¯ä»¥å·§å¦™çš„åœ¨ find è¿‡ç¨‹ä¸­å®Œæˆï¼Œå¦‚ä¸‹ï¼š
         */
        return (this.father[u] = find(this.father[u]))
    }
}
```

- å¯å‘å¼åˆå¹¶ï¼š

    ä¸Šé¢çš„åˆå¹¶æ¯”è¾ƒéšæ„ï¼Œåˆå¹¶æ—¶ï¼Œé€‰æ‹©å“ªæ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºæ–°æ ‘çš„æ ¹èŠ‚ç‚¹ä¼šå½±å“æœªæ¥æ“ä½œçš„å¤æ‚åº¦ã€‚æˆ‘ä»¬å¯ä»¥å°†èŠ‚ç‚¹è¾ƒå°‘æˆ–æ·±åº¦è¾ƒå°çš„æ ‘è¿åˆ°å¦ä¸€æ£µã€‚å°†è¾ƒå°é›†åˆåˆå¹¶åˆ°è¾ƒå¤§é›†åˆæœ‰åŠ©äºå¹³è¡¡æ ‘çš„é«˜åº¦ï¼Œä»è€Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚

    ```js
    // constructor
    this.size = Array(size).fill(1)

    union(u, y) {
        u = this.find(u);
        v = this.find(v);
        if (u === v) return
        if (this.size[u] < this.size[v]) {
            [u, v] = [v, u];
        }
        this.father[v] = u;
        this.size[u] += this.size[v];
    }
    ```

#### ç»ƒä¹ 

##### lc.684 å†—ä½™è¿æ¥

æ£€æµ‹æ— å‘å›¾çš„ç¯~ æ€æƒ³ä¹Ÿå¾ˆç®€å•ï¼Œåˆ©ç”¨å¹¶æŸ¥é›†çš„ findï¼Œå½“æ–°åŠ å…¥çš„è¾¹å¦‚æœæ‰¾åˆ°äº†åŒä¸€ä¸ªæ ¹ï¼Œåˆ™è¯´æ˜æ–°åŠ å…¥çš„è¾¹ä½¿å¾—åŸæ¥çš„æ ‘å½¢æˆäº†ç¯ï¼›å¦åˆ™å°± union æ–°åŠ å…¥çš„è¾¹å³å¯ã€‚

```js
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantConnection = function (edges) {
    const len = edges.length
    const DSU = Array.from(Array(len + 1), (_, index) => index)
    for (let i = 0; i < len; ++i) {
        const [u, v] = edges[i]
        const u1 = find(DSU, u)
        const v1 = find(DSU, v)
        if (u1 === v1) return edges[i]
        DSU[v1] = u1 // union ç®€åŒ–åˆ°è¿™é‡Œ
    }
    return [0]
}
function find(p, u) {
    if (u === p[u]) return u
    return (p[u] = find(p, p[u]))
}
```

##### lc.130 è¢«å›´ç»•çš„åŒºåŸŸ

```js
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function (board) {
    if (board.length === 0) return
    // è¿™é“é¢˜ä¸€çœ‹å°±æ˜¯å²›å±¿ç±»çš„é—®é¢˜ï¼Œè‡ªç„¶å¯ä»¥ç”¨ flood fill ç®—æ³•å»æå®šï¼Œä½†æœ¬æ¬¡é‡ç‚¹æ˜¯å¹¶æŸ¥é›†~
    const rowLen = board.length
    const colLen = board[0].length

    const DSU = Array.from(Array(rowLen * colLen + 1), (_, index) => index) // å¤šä¸€ä¸ªæœ€åçš„èŠ‚ç‚¹ç”¨äºç»™ dummyNode
    const dummyNode = rowLen * colLen // å¦‚æœä¸ç”¨ dummyNode å°±ç•¥å¾®å¤æ‚äº†

    // éå†å››æ¡ä»¶è¾¹ï¼ŒæŠŠå››æ¡è¾¹ä¸Šçš„ O ä¸ dummyNode è¿é€š
    for (let i = 0; i < rowLen; ++i) {
        if (board[i][0] === 'O') union(DSU, i * colLen, dummyNode)
        if (board[i][colLen - 1] === 'O') union(DSU, i * colLen + colLen - 1, dummyNode)
    }
    for (let j = 0; j < colLen; ++j) {
        if (board[0][j] === 'O') union(DSU, j, dummyNode)
        if (board[rowLen - 1][j] === 'O') union(DSU, (rowLen - 1) * colLen + j, dummyNode)
    }

    // éå†æ•´ä¸ªå†…éƒ¨èŠ‚ç‚¹ï¼ŒæŠŠæ‰€æœ‰çš„ O è¿é€šèµ·æ¥ï¼ˆè¿å®Œåï¼Œå¦‚æœå’Œè¾¹ç¼˜è¿æ¥çš„å°±ä¼šåœ¨ä¸€ä¸ªé›†åˆï¼Œå¦åˆ™åœ¨å¦ä¸€ä¸ªé›†åˆï¼‰
    // åˆ©ç”¨æ–¹å‘æ•°ç»„éå†ä¸Šä¸‹å·¦å³
    const dirs = [
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
    ]
    for (let i = 1; i < rowLen - 1; ++i) {
        for (let j = 1; j < colLen - 1; ++j) {
            if (board[i][j] === 'O') {
                for (const [x, y] of dirs) {
                    const nx = i + x
                    const ny = j + y
                    if (board[nx][ny] === 'O') {
                        union(DSU, i * colLen + j, nx * colLen + ny)
                    }
                }
            }
        }
    }
    // éå†æ•´ä¸ª boardï¼Œ æŠŠä¸­é—´åŒ…å›´çš„ä¸”æ²¡æœ‰å’Œ dummyNode è¿é€šçš„ O å˜ä¸º X
    for (let i = 1; i < rowLen - 1; ++i) {
        for (let j = 1; j < colLen - 1; ++j) {
            if (board[i][j] === 'O' && find(DSU, i * colLen + j) !== find(DSU, dummyNode)) {
                board[i][j] = 'X'
            }
        }
    }
}
function find(p, u) {
    if (u === p[u]) return u
    return (p[u] = find(p, p[u]))
}
function union(p, u, v) {
    u = find(p, u)
    v = find(p, v)
    if (u === v) return
    p[v] = u
}
```

- ç®€å•è¯´ä¸€ä¸‹ï¼Œç”¨ flood fill ç®—æ³•æ€ä¹ˆåšï¼Œä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯å…ˆ dfs å››æ¡è¾¹ï¼Œå…ˆæŠŠä¸è¾¹ç›¸è¿çš„ O éƒ½æ ‡è®°ä¸Šï¼Œæœ€åå¯¹æ•´ä¸ª board éå†ï¼ŒæŠŠ O è½¬ä¸º xï¼ŒæŠŠæ ‡è®°çš„è½¬å›ä¸º O å³å¯ã€‚ lc.200 & lc.1905 ä¸æœ¬é¢˜ç±»ä¼¼ï¼Œä¹‹å‰ç”¨çš„ dfs flood fill ç®—æ³•å»åšçš„ï¼Œæœ‰æ—¶é—´å¯ä»¥ç”¨ DSU ä¹Ÿåšä¸€åšã€‚

è¿™æ˜¯ä¸ä½¿ç”¨è™šæ‹ŸèŠ‚ç‚¹çš„å¹¶æŸ¥é›†ï¼Œå°±å¾—éœ€è¦ç»´æŠ¤ isEdge æ¥æ ‡è®°æ˜¯å¦ä¸è¾¹ç¼˜ç›¸è¿äº†

```js
class UnionFind {
    constructor(n) {
        this.parent = new Array(n).fill(null).map((_, idx) => idx)
        this.isEdge = new Array(n).fill(false) // æ ‡è®°æ˜¯å¦ä¸è¾¹ç¼˜ç›¸è¿
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x])
        }
        return this.parent[x]
    }

    union(x, y) {
        let rootX = this.find(x)
        let rootY = this.find(y)

        if (rootX !== rootY) {
            this.parent[rootY] = rootX
            // æ›´æ–°rootXçš„è¾¹ç¼˜çŠ¶æ€
            this.isEdge[rootX] = this.isEdge[rootX] || this.isEdge[rootY]
        }
    }
}

/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function (board) {
    if (board.length === 0) {
        return
    }

    const rows = board.length
    const cols = board[0].length
    const uf = new UnionFind(rows * cols)

    // å®šä¹‰è¾¹ç•Œæ¡ä»¶
    const isEdge = (i, j) => i == 0 || i == rows - 1 || j == 0 || j == cols - 1

    // éå†çŸ©é˜µä¸­æ‰€æœ‰çš„'O'èŠ‚ç‚¹
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (board[i][j] === 'O') {
                let idx = i * cols + j
                // å¦‚æœæ˜¯è¾¹ç¼˜èŠ‚ç‚¹ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºä¸è¾¹ç¼˜ç›¸è¿
                uf.isEdge[idx] = isEdge(i, j)

                // å°†å½“å‰'O'èŠ‚ç‚¹ä¸ç›¸é‚»çš„'O'èŠ‚ç‚¹è¿›è¡Œè¿æ¥
                let neighbors = [
                    [i + 1, j],
                    [i - 1, j],
                    [i, j + 1],
                    [i, j - 1]
                ]
                for (let [ni, nj] of neighbors) {
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && board[ni][nj] === 'O') {
                        uf.union(idx, ni * cols + nj)
                    }
                }
            }
        }
    }

    // éå†çŸ©é˜µï¼Œå°†ä¸ä¸è¾¹ç¼˜ç›¸è¿çš„'O'èŠ‚ç‚¹æ”¹ä¸º'X'
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (board[i][j] === 'O' && !uf.isEdge[uf.find(i * cols + j)]) {
                board[i][j] = 'X'
            }
        }
    }
}
```

##### lc.990 ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§

çŸ¥é“ç”¨å¹¶æŸ¥é›†çš„å‰æä¸‹ï¼Œè¿™è¿˜ä¸æ˜¯å° case~ åˆæ˜¯ä¸€ä¸ªæ— å‘å›¾æ£€æµ‹ç¯çš„é—®é¢˜ç½¢äº†ã€‚

```js
/**
 * @param {string[]} equations
 * @return {boolean}
 */
var equationsPossible = function (equations) {
    // å¾ˆæ˜æ˜¾çš„ç¯æ£€æµ‹é—®é¢˜
    const DSU = Array.from(Array(26), (_, index) => index)
    for (let i = 0; i < equations.length; ++i) {
        const edge = equations[i]
        const isConnected = edge[1] === '='
        if (isConnected) {
            const u = edge.charCodeAt(0) - 'a'.charCodeAt()
            const v = edge.charCodeAt(3) - 'a'.charCodeAt()
            union(DSU, u, v)
        }
    }
    for (let i = 0; i < equations.length; ++i) {
        const edge = equations[i]
        const isNotConnected = edge[1] === '!'
        if (isNotConnected) {
            const u = edge.charCodeAt(0) - 'a'.charCodeAt()
            const v = edge.charCodeAt(3) - 'a'.charCodeAt()
            if (find(DSU, u) === find(DSU, v)) return false
        }
    }
    return true
}
function find(p, u) {
    if (u === p[u]) return u
    return (p[u] = find(p, p[u]))
}
function union(p, u, v) {
    u = find(p, u)
    v = find(p, v)
    if (u === v) return
    p[v] = u
}
```

{/* å¹¶æŸ¥é›†åœ¨ç»è¿‡ä¿®æ”¹åå¯ä»¥æ”¯æŒå•ä¸ªå…ƒç´ çš„åˆ é™¤ã€ç§»åŠ¨ï¼›ä½¿ç”¨åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘è¿˜å¯ä»¥å®ç°å¯æŒä¹…åŒ–å¹¶æŸ¥é›†ã€‚ */}
