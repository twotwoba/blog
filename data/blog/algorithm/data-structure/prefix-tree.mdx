---
title: 'å‰ç¼€æ ‘'
summary: 'æµ…å­¦ä¸€ä¸‹å‰ç¼€æ ‘, ä¹Ÿå«å­—å…¸æ ‘ğŸŒ²'
date: '2022-11-13'
tags: ['data structure']
images: []
---

## æ¦‚å¿µåŠå®ç°

å‰ç¼€æ ‘ï¼Œä¹Ÿå«å­—å…¸æ ‘ï¼Œå°±æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚æœ‰ä¸€ç»„å­—ç¬¦ä¸² `['abc', 'ab', 'bc', 'bck']`ï¼Œé‚£ä¹ˆå®ƒçš„å‰ç¼€æ ‘æ˜¯è¿™æ ·çš„ï¼š

<img src="https://cdn.jsdelivr.net/gh/yokiizx/picgo@main/img/202402131753139.png" className="w-[200px]" />

æ ¸å¿ƒï¼š**å­—ç¬¦åœ¨æ ‘çš„æ ‘æä¸Šï¼ŒèŠ‚ç‚¹ä¸Šä¿å­˜ç€ä¿¡æ¯** (å½“ç„¶ä¸æ˜¯è¿™ä¹ˆæ­»ï¼Œä¸ªäººä¹ æƒ¯ï¼Œç¨‹åºæ€ä¹ˆå®ç°éƒ½æ˜¯ ok çš„)ï¼Œå«ä¹‰å¦‚ä¸‹ï¼š

- pï¼šé€šè¿‡æ ‘æå­—ç¬¦çš„å­—ç¬¦ä¸²æ•°é‡. -- å¯ä»¥æŸ¥è¯¢å‰ç¼€æ•°é‡
- eï¼šä»¥æ ‘æå­—ç¬¦ç»“å°¾çš„å­—ç¬¦ä¸²æ•°é‡. -- å¯ä»¥æŸ¥è¯¢å­—ç¬¦ä¸²

å¯¹åº”çš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š

```js
class TrieNode {
    constructor(pass = 0, end = 0) {
        this.pass = pass // é€šè¿‡ä¸‹æ¥æ ‘æå­—ç¬¦çš„å­—ç¬¦ä¸²æ•°é‡
        this.end = end // ä»¥ä¸Šæ¥æ ‘æå­—ç¬¦ç»“å°¾çš„å­—ç¬¦ä¸²æ•°é‡
        this.next = {} // {char: TrieNode} çš„ map é›†ï¼Œ å­—ç¬¦æœ‰é™ï¼Œæœ‰äº›æ•™ç¨‹ä¹Ÿç”¨æ•°ç»„å®ç°ï¼›next çš„ key å°±å¯ä»¥æŠ½è±¡ä¸ºæ ‘æ
    }
}
class Trie {
    constructor() {
        this.root = new TrieNode()
    }
    insert(str) {
        let p = this.root
        for (const c of str) {
            if (!p.next[c]) {
                p.next[c] = new TrieNode()
            }
            p = p.next[c]
            p.pass++
        }
        p.end++
    }
    // æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚æ ¹æ®å®é™…é—®é¢˜ï¼Œçœ‹æ˜¯è¿”å› Boolean è¿˜æ˜¯  end
    search(str) {
        let p = this.root
        for (const c of str) {
            if (!p.next[c]) return 0
            // if (!p.next[c].pass) return 0 // æ ¹æ®å®é™…æƒ…å†µçœ‹æ˜¯å¦éœ€è¦åšä»€ä¹ˆé¢å¤–æ“ä½œ
            p = p.next[c]
        }
        return p.end
    }
    // æœ‰å‡ ä¸ªä»¥ str ä¸ºå‰ç¼€çš„å­—ç¬¦ä¸²ã€‚æ ¹æ®å®é™…é—®é¢˜ï¼Œçœ‹æ˜¯è¿”å› Boolean è¿˜æ˜¯ pass
    startWidth(str) {
        let p = this.root
        for (const c of prefix) {
            if (!p.next[c]) return 0
            // if (!p.next[c].pass) return 0 // æ ¹æ®å®é™…æƒ…å†µçœ‹æ˜¯å¦éœ€è¦åšä»€ä¹ˆé¢å¤–æ“ä½œ
            p = p.next[c]
        }
        return p.pass
    }
    delete(str) {
        if (this.search(str) !== 0) {
            let p = this.root
            p.pass--
            for (const c of str) {
                p.next[c].pass--
                if (p.next[c].pass == 0) {
                    p.next[c] = null // å½“æŸä¸ªèŠ‚ç‚¹çš„ pass ä¸º 0 çš„æ—¶å€™ï¼Œè¯´æ˜åé¢éƒ½æ²¡å¾—äº†ï¼Œå¯ä»¥ç›´æ¥æŠŠåç»­ç½® null äº†
                    return
                }
                p = p.next[c]
            }
            p.end--
        }
    }
}
```

## ç»ƒä¸€ç»ƒ

### lc.208 å®ç°å‰ç¼€æ ‘

```js
/**
 * è‡ªå®šä¹‰å‰ç¼€æ ‘èŠ‚ç‚¹
 */

class TrieNode {
    constructor() {
        this.pass = 0
        this.end = 0
        this.next = {}
    }
}
var Trie = function () {
    this.root = new TrieNode()
}

/**
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function (word) {
    let p = this.root
    for (const c of word) {
        if (!p.next[c]) {
            p.next[c] = new TrieNode()
        }
        p = p.next[c]
        p.pass++
    }
    p.end++
}

/**
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function (word) {
    let p = this.root
    for (const c of word) {
        if (!p.next[c]) return false
        p = p.next[c]
    }
    return p.end > 0
}

/**
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function (prefix) {
    let p = this.root
    for (const c of prefix) {
        if (!p.next[c]) return false
        p = p.next[c]
    }
    return true
}

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

### lc.211 æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡

```js
class TrieNode {
    constructor(pass = 0, end = 0) {
        this.pass = pass
        this.end = end
        this.next = {}
    }
}
var WordDictionary = function () {
    this.root = new TrieNode()
}

/**
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function (word) {
    let p = this.root
    for (const c of word) {
        if (!p.next[c]) {
            p.next[c] = new TrieNode()
        }
        p = p.next[c]
        p.pass++
    }
    p.end++
}

/**
 * @param {string} word
 * @return {boolean}
 */
// æ³¨æ„ç¬¬äºŒä¸ªå‚æ•° æ˜¯åæ¥è‡ªå·±å†™çš„æ—¶å€™æ·»åŠ çš„ï¼Œå› ä¸ºè¦å¯»æ‰¾ . ä¹‹åçš„
WordDictionary.prototype.search = function (word, newRoot) {
    let p = this.root
    if (newRoot) p = newRoot
    for (let i = 0; i < word.length; ++i) {
        const c = word[i]
        if (c === '.') {
            // å…³é”®åœ¨æ€ä¹ˆå¤„ç†è¿™é‡Œï¼Œå› ä¸º . åŒ¹é…ä»»æ„å­—ç¬¦
            // æœ€ç›´è§‚çš„åšæ³•å°±æ˜¯æŠŠ . æ›¿æ¢æˆå¯èƒ½å¾—å­—ç¬¦ï¼Œç„¶åæŒ¨ä¸ªå°è¯•
            if (i === word.length) return true
            const keys = Object.keys(p.next)
            // ä¸€å¼€å§‹è¿™ä¹ˆå†™çš„ï¼Œç¼ºå°‘äº† startï¼Œæ¯æ¬¡éƒ½ä»å¤´å¼€å§‹æœç´¢ï¼Œè¿™å°±ä¸å¯¹äº†ï¼Œé‚£å°±æŠŠ p å¸¦ä¸Š
            // return keys.some(d => this.search(d + word.slice(i + 1)))
            return keys.some((d) => this.search(d + word.slice(i + 1), p))
        } else {
            if (!p.next[c]) return false
            p = p.next[c]
        }
    }
    return p.end > 0
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
/** è¿™é¢˜æˆ‘å†™çš„å’Œå®˜è§£ç•¥æœ‰ä¸åŒï¼Œä½†æ€»ä½“æ€è·¯éƒ½æ˜¯æ·±åº¦ä¼˜å…ˆéå† dfs */
```

### lc.648 å•è¯æ›¿æ¢

```js
/**
 * @param {string[]} dictionary
 * @param {string} sentence
 * @return {string}
 */
var replaceWords = function (dictionary, sentence) {
    let trie = new Trie()
    dictionary.forEach((s) => trie.insert(s))

    return sentence
        .split(' ')
        .map((s) => trie.search(s))
        .join(' ')
}
// è¯»è¿™é“é¢˜æ„ï¼Œå¾ˆå®¹æ˜“æƒ³å¾—åˆ° å‰ç¼€æ ‘
class TrieNode {
    constructor(pass = 0, end = 0) {
        this.pass = pass
        this.end = end
        this.next = {}
    }
}
class Trie {
    constructor() {
        this.root = new TrieNode()
    }
    insert(str) {
        let p = this.root
        for (const c of str) {
            if (!p.next[c]) {
                p.next[c] = new TrieNode()
            }
            p = p.next[c]
            p.pass++
        }
        p.end++
    }
    search(str) {
        let p = this.root
        let i = 0
        for (const c of str) {
            if (!p.next[c]) {
                return p.end > 0 ? str.slice(0, i) : str
            }
            p = p.next[c]
            i++
            /**
             * ä¸€å¼€å§‹è¿™ä¸¤ä¸ªè¾¹ç•Œæ¡ä»¶æˆ‘ç»™æ¼äº†ã€‚ã€‚ã€‚
             * ä¸€ä¸ªæ˜¯ p èµ°åˆ°å¤´äº†ï¼Œ ä¸€ä¸ªæ˜¯ i èµ°åˆ°å¤´äº†~
             */
            if (p.end > 0) return str.slice(0, i)
            if (i === str.length && p.pass > 0) return str
        }
    }
}
```

### lc.677 é”®å€¼æ˜ å°„

```js
class TrieNode {
    constructor(pass = 0, end = 0) {
        this.pass = pass
        this.end = end
        this.val = 0
        this.next = {}
    }
}
var MapSum = function () {
    this.root = new TrieNode()
}

/**
 * @param {string} key
 * @param {number} val
 * @return {void}
 */
MapSum.prototype.insert = function (key, val) {
    let p = this.root
    for (const c of key) {
        if (!p.next[c]) {
            p.next[c] = new TrieNode()
        }
        p = p.next[c]
        p.pass++
    }
    p.end++
    p.val = val
}

/**
 * @param {string} prefix
 * @return {number}
 */
MapSum.prototype.sum = function (prefix) {
    let p = this.root
    for (const c of prefix) {
        if (!p.next[c]) return 0
        p = p.next[c]
    }
    // é€’å½’æŸ¥æ‰¾ä¹‹åæ‰€æœ‰çš„ val å¹¶ç´¯åŠ å³å¯
    let sum = 0
    /** ç¬¬ä¸€æ¬¡åšï¼Œæ¼æ‰äº†æ°å¥½ç›¸ç­‰çš„æ¡ä»¶ */
    if (p && p.end > 0) sum += p.val
    const getVal = (p) => {
        if (!p) return
        const allKeys = Object.keys(p.next)
        if (!allKeys.length) return
        allKeys.forEach((c) => {
            let newP = p // ç¬¬ä¸€æ¬¡åšï¼Œè¿™é‡Œä¹Ÿå¿˜è®°å¤„ç†äº†ã€‚ã€‚ã€‚
            newP = newP.next[c]
            if (newP && newP.end > 0) sum += newP.val
            getVal(newP)
        })
    }
    getVal(p)
    return sum
}

/**
 * Your MapSum object will be instantiated and called as such:
 * var obj = new MapSum()
 * obj.insert(key,val)
 * var param_2 = obj.sum(prefix)
 */
```

è¿™é“é¢˜æˆ‘çº¯ç”¨å‰ç¼€æ ‘å®ç°äº†ï¼Œé€’å½’çš„è¿‡ç¨‹æœ‰ç‚¹è´¹æ—¶é—´ï¼Œä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ï¼Œè‡ªç„¶ä¸Š hashMapï¼Œå®˜è§£é‡Œæœ‰å®ç°ï¼Œè‡ªè¡Œç†è§£ã€‚

---

## å¸¸è§åœºæ™¯

å‰ç¼€æ ‘çš„ä½œç”¨ï¼š

1. æŸ¥è¯¢å­—ç¬¦ä¸²
2. æŸ¥è¯¢ä»¥æŸä¸ªå­—ç¬¦ä¸²ä¸ºå‰ç¼€çš„å­—ç¬¦ä¸²æœ‰å¤šå°‘ä¸ª
3. è‡ªåŠ¨è¡¥å®Œ

ä¸Šé¢ä¸¤ä¸ªä½œç”¨ï¼Œç¬¬ä¸€ä¸ª hashMap ä¹Ÿèƒ½åšåˆ°ï¼Œä½†æ˜¯å…¶ä»–ç‚¹ï¼Œåˆ™æ˜¯å‰ç¼€æ ‘å‘æŒ¥å…¶æœ¬é¢†çš„ç»å¯¹é¢†åœ°äº†ã€‚
