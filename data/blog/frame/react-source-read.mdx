---
title: 'React æºç é˜…è¯»ï¼ˆv18.2.0ï¼‰'
date: '2024-07-31 18:23:18'
# lastmod: '1900-01-01'
tags: ['react']
draft: true
summary: "ä¹Ÿæ˜¯ä¸€ä¸ª React ä½¿ç”¨äº† 4 å¹´çš„é€‰æ‰‹äº†ï¼Œæƒ³å½“å‡ºè‡ªå·±å’¬ç‰™å•ƒ React æºç ä¸€çŸ¥åŠè§£ï¼Œåæ¥çœ‹äº†å¾ˆå¤šå¤§ä½¬çš„æ–‡ç« é¢‡æœ‰æ”¶è·ï¼Œå¿™é‡Œå·é—²ï¼Œæ¸©æ•…è€ŒçŸ¥æ–°ä¸€ä¸‹ä¸‹ï¼Œlet's goğŸ§¨"
images: []
layout: PostLayout
---

## Overview

<TOCInline toc={props.toc} exclude="Overview" toHeading={3} />

---

## å‰ç½®

- [ä½è¿ç®—](https://www.twotwoba.site/blog/algorithm/bit-operation#%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7)ï¼ŒReact æºç ä¸­å­˜åœ¨å¤§é‡ä½è¿ç®—ï¼Œå»ºè®®å…ˆçœ‹çœ‹
- [ä¼˜å…ˆé˜Ÿåˆ—](https://www.twotwoba.site/blog/algorithm/priority-queue)ï¼ŒReact è°ƒåº¦ç®—æ³•ä¸­ä½¿ç”¨äº†å°é¡¶å †
- [React è°ƒè¯•æºç æŠ€å·§](https://www.twotwoba.site/blog/frame/react-source-debug)ï¼Œäº²è‡ªè°ƒè¯•ï¼Œæ‰èƒ½å°è±¡æ·±åˆ»å“¦

## å®è§‚åŸºç¡€æ¦‚å¿µ

å››ä¸ªå…³é”®åŒ…ï¼š
- `react`ï¼Œå¯¹å¤–æš´éœ² APIï¼Œåªæä¾›å®šä¹‰ react ç»„ä»¶çš„å¿…è¦å‡½æ•°ï¼Œå¦‚ `ReactElement`
- `react-dom`ï¼Œæ¸²æŸ“å™¨ï¼Œæ‰¿æ‹…`å¯åŠ¨ react æ¸²æŸ“æµç¨‹`å’Œ`æŠŠ reconciler æ„é€ å‡ºæ¥çš„ fiber æ ‘è¡¨ç°å‡ºæ¥çš„`ä½œç”¨ï¼ˆç”Ÿæˆ dom èŠ‚ç‚¹(æµè§ˆå™¨ä¸­), ç”Ÿæˆå­—ç¬¦ä¸²(ssr)ï¼‰
- `react-reconciler`ï¼Œç»¼åˆåè°ƒå¦å¤–ä¸‰ä¸ªåŒ…
    - æ¥æ”¶ `react-dom` ï¼ˆåˆæ¬¡ renderï¼‰ å’Œ `react` ï¼ˆåç»­ setStateï¼‰ å¼•èµ·çš„æ›´æ–°
    - æŠŠæ„é€  fiber æ ‘çš„è¿‡ç¨‹åŒ…è£…åœ¨ä¸€ä¸ªå›è°ƒå‡½æ•°ä¸­ï¼Œå¹¶å°†æ­¤å›è°ƒå‡½æ•°ä¼ å…¥ `scheduler` ç­‰å¾…è°ƒåº¦ã€‚å›è°ƒå‡½æ•°ï¼š`performSyncWorkOnRoot/performConcurrentWorkOnRoot`
- `scheduler`ï¼Œé¡¾åæ€ä¹‰è¿™ä¸ªåŒ…èµ·åˆ°äº†è°ƒåº¦çš„ä½œç”¨ï¼Œæ§åˆ¶ç€ä» `reconciler` ä¼ å…¥çš„å›è°ƒå‡½æ•°çš„æ‰§è¡Œæ—¶æœºï¼Œ`concurrent` æ¨¡å¼ä¸‹å¯ä»¥å®ç°ä»»åŠ¡åˆ†ç‰‡

## æ ¸å¿ƒæŠ½è±¡ç†å¿µ

- `åŒç¼“å­˜`ï¼Œåœ¨ React ä¸­æœ€å¤šåŒæ—¶å­˜åœ¨ä¸¤ä¸ª Fiber ğŸŒ²
  - å½“å‰å±å¹•æ˜¾ç¤ºå†…å®¹å¯¹åº”çš„ Fiber æ ‘ï¼Œ`current Fiber æ ‘`
  - å‘ç”Ÿæ›´æ–°ï¼Œæ­£åœ¨å†…å­˜ä¸­æ„å»ºçš„ Fiber æ ‘ï¼Œ`workInProgress Fiber æ ‘`  

  æ ¹ `fiberRootNode` çš„ `current` æŒ‡é’ˆåœ¨ä¸åŒ Fiber æ ‘çš„ `rootFiber` ä¹‹é—´åˆ‡æ¢ --- å½“ workInProgress Fiber æ ‘æ„å»ºå®Œæˆäº¤ç»™æ¸²æŸ“å™¨æ¸²æŸ“åˆ°é¡µé¢åï¼Œcurrent æŒ‡é’ˆå°±åˆ‡æ¢åˆ° workInProgress Fiber æ ‘ï¼Œå®ƒä¹Ÿè½¬å˜ä¸º current Fiber æ ‘äº†ï¼ˆé•¿å¤§åæˆ‘å°±æˆäº†ä½ ï¼‰~
- `åŒå¾ªç¯`ï¼Œ
  - è°ƒåº¦å¾ªç¯
  - æ„å»ºå¾ªç¯
---

## å¯åŠ¨è¿‡ç¨‹

![createRoot](/static/images/react/ReactDomRoot.png)

ä¸Šå›¾æ˜¯ä¸€ä¸ª React é¡¹ç›®å¯åŠ¨çš„åŸºæœ¬æµç¨‹ï¼Œé€šè¿‡è°ƒè¯•æºç ï¼Œç†è§£èµ·æ¥ç›¸å¯¹è¾ƒå®¹æ˜“ã€‚

- `createRoot`ï¼Œä¸»è¦ä½¿å‘½åˆ›å»ºäº† `FiberRoot` å’Œ `HostFiberRoot`ï¼Œä¸¤è€…çš„è¿æ¥è§å›¾
    - `FiberRoot` ä¸»è¦å­˜å‚¨äº†æ„å»º `Fiber` è¿‡ç¨‹ä¸­çš„å…¨å±€çŠ¶æ€
    - `HostRootFiber` æ˜¯ç¬¬ä¸€ä¸ª `Fiber` èŠ‚ç‚¹ï¼Œ`markContainerAsRoot` å°†å®ƒå’Œ `container` å…³è”èµ·æ¥äº†
- `render`ï¼Œæ˜¯ `ReactDOMRoot` å¯¹è±¡åŸå‹ä¸Šçš„æ–¹æ³•ï¼Œå†…éƒ¨è°ƒç”¨äº† `updateContainer->scheduleUpdateOnFiber` è¿›å…¥åè°ƒæµç¨‹


ç›®å‰ï¼Œæˆ‘ä»¬æ¸…æ¥šçš„çŸ¥é“ `react-dom` åŒ…ä½œä¸º**æ¸²æŸ“å™¨**åˆå§‹å¯åŠ¨çš„å¤§ä½“æµç¨‹ã€‚

## åè°ƒè¿‡ç¨‹

`scheduleUpdateOnFiber` æ˜¯ `react-reconciler` æ ¸å¿ƒçš„å…¥å£ï¼Œåœ¨ `ReactFiberWorkLoop.js` æ–‡ä»¶ä¸­ã€‚

![reconciler](/static/images/react/reconciler.png)

```js:scheduleUpdateOnFiber
export function scheduleUpdateOnFiber(
  root: FiberRoot,
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // æŠŠæ›´æ–°çš„ lane å’Œ eventTime æŒ‚è½½åˆ° fiberRoot å¯¹åº”çš„å±æ€§ä¸ŠpendingLaneså’ŒeventTimes
  // Mark that the root has a pending update.
  markRootUpdated(root, lane, eventTime);

  // å­—é¢ç¿»è¯‘ï¼šæ‰§è¡Œä¸Šä¸‹æ–‡åŒ…å«æ¸²æŸ“ä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸” workInProgressRoot ä¸ºå½“å‰ FiberRoot
  // ä¸ªäººç†è§£: è¿™é‡Œçš„é€»è¾‘å°±æ˜¯å¤„ç†æ¸²æŸ“è¿‡ç¨‹ä¸­çš„æ›´æ–°
  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {
    // è¿½è¸ªæ¸²æŸ“é˜¶æ®µçš„ lane
    // Track lanes that were updated during the render phase.
    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
      workInProgressRootRenderPhaseUpdatedLanes,
      lane,
    );
  } else {
    if (root === workInProgressRoot) {
      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
        markRootSuspended(root, workInProgressRootRenderLanes);
      }
    }
    // ...
    /**
     * é‡ç‚¹ï¼šreconciler ä¸ scheduler äº¤äº’çš„å…¥å£ã€‚è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯å»è°ƒåº¦ä¸­å¿ƒæ³¨å†Œä»»åŠ¡ï¼Œç­‰å¾…å›è°ƒæ‰§è¡Œ
     */
    ensureRootIsScheduled(root, eventTime);
    // ...
  }
}
```
```js:ensureRootIsScheduled
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  // FiberRoot.callbackNode çš„æ˜¯ç”± Scheduler.scheduleCallback è¿”å›çš„ Nodeï¼Œä»£è¡¨ç€ä¸‹ä¸€æ¬¡å°†è¦æ‰§è¡Œçš„æ¸²æŸ“ä»»åŠ¡
  const existingCallbackNode = root.callbackNode;

  // è¢«å…¶ä»–é«˜ä¼˜å…ˆçº§å·¥ä½œâ€œé¥¿æ­»â€çš„ lane è¿›è¡Œæ ‡è®°ï¼Œä»¥ä¾¿åœ¨ä¸‹æ¬¡è°ƒåº¦æ—¶ä¼˜å…ˆå¤„ç†è¿™äº› lane
  markStarvedLanesAsExpired(root, currentTime);

  // Determine the next lanes to work on, and their priority.
  const nextLanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );

  // ...
  
  // å–å‡º nextLanes ä¸­çš„æœ€é«˜ä¼˜å…ˆçº§ï¼ˆlanes & -lanesï¼‰
  const newCallbackPriority = getHighestPriorityLane(nextLanes);

  // fiberRoot ä¸Šçš„å›è°ƒä¼˜å…ˆçº§å¦‚æœå’Œæ–°çš„æœ€é«˜ä¼˜å…ˆçº§ç›¸åŒï¼Œç›´æ¥å¤ç”¨
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority === newCallbackPriority) {
    return;
  }

  // ä¼˜å…ˆçº§ä¸åŒä¸”å›è°ƒèŠ‚ç‚¹å­˜åœ¨ï¼Œåˆ™å–æ¶ˆè¯¥å›è°ƒï¼Œå¹¶ä¸”åç»­ schedule ä¸€ä¸ªæ–°çš„å›è°ƒä»»åŠ¡
  if (existingCallbackNode != null) {
    cancelCallback(existingCallbackNode);
  }

  // Schedule a new callback.
  let newCallbackNode;
  // æœ¬åœ°è°ƒåº¦ä¼˜å…ˆçº§æœ€é«˜çš„lane æ˜¯ SyncLneï¼Œåˆ™èµ°ã€ŒåŒæ­¥è°ƒåº¦ã€ï¼Œå¦åˆ™èµ° ã€Œå¼‚æ­¥è°ƒåº¦ã€
  if (newCallbackPriority === SyncLane) {
    // è°ƒç”¨ scheduleSyncCallbackï¼ŒæŠŠ performSyncWorkOnRoot.bind(null, root) å›è°ƒå‡½æ•°è£…è½½åˆ° syncQueue é˜Ÿåˆ—ä¸­
    // æ”¯æŒå¾®ä»»åŠ¡å°± flushSyncCallbacks æŠŠ syncQueue ä¸­çš„å›è°ƒæ‰§è¡Œå®Œï¼Œå¦åˆ™è°ƒç”¨ scheduleCallback(ImmediatePriority, flushSyncCallbacks)
    // èµ‹äºˆ ImmediateSchedulerPriority å³ç«‹å³è°ƒåº¦çš„ä¼˜å…ˆçº§
  } else {
    // éåŒæ­¥ä¸‹ï¼Œè¦å°† lanes è½¬åŒ–ä¸ºè°ƒåº¦çš„ä¼˜å…ˆçº§
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
  // æŒ‚è½½æ–°çš„å›è°ƒä¼˜å…ˆçº§å’Œå›è°ƒèŠ‚ç‚¹åˆ° fiberRoot ä¸Š
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
```

æ­¤å¤„çš„ `scheduleCallback` å¼•ç”¨çš„ `Scheduler.unstable_scheduleCallback` æ–¹æ³•ï¼Œåœ¨åé¢çš„è°ƒåº¦è¿‡ç¨‹è¯¦ç»†åˆ†æï¼Œå…ˆç€é‡åˆ†æä¸€ä¸‹ `performSyncWorkOnRoot/performConcurrentWorkOnRoot`.

```js:performSyncWorkOnRoot
function performSyncWorkOnRoot(root) {
  // ...éƒ¨åˆ†ä»£ç çœç•¥

  // å¤„ç† passive effectï¼ˆå³è§¦å‘ useEffect çš„åˆ›å»ºã€é”€æ¯å‡½æ•°åŠå…¶ä»–åŒæ­¥ä»»åŠ¡ï¼‰
  flushPassiveEffects();

  let lanes = getNextLanes(root, NoLanes);
  // å¦‚æœæ²¡æœ‰éœ€è¦å¤„ç†çš„ä»»åŠ¡ï¼Œç›´æ¥è¿”å›
  if (!includesSomeLane(lanes, SyncLane)) {
    ensureRootIsScheduled(root, now());
    return null;
  }

  // æ„å»º fiber æ ‘
  let exitStatus = renderRootSync(root, lanes);

  // ...æ ¹æ® exitStatus åšä¸€äº›å¼‚å¸¸å¤„ç†ä»£ç çœç•¥

  // æ¸²æŸ“ fiber æ ‘
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  // è¿›å…¥ commit é˜¶æ®µ
  commitRoot(
    root,
    workInProgressRootRecoverableErrors,
    workInProgressTransitions,
  );

  // é€€å‡ºå‰å†æ¬¡æ£€æµ‹æ˜¯å¦æœ‰å…¶ä»–æ›´æ–°
  ensureRootIsScheduled(root, now());

  return null;
}
```
```js:performConcurrentWorkOnRoot
function performConcurrentWorkOnRoot(root, didTimeout) {
  // ...éƒ¨åˆ†ä»£ç çœç•¥
  // å½“å‰åœ¨ React äº‹ä»¶ä¸­å¯ä»¥æ¸…é™¤å½“å‰äº‹ä»¶æ—¶é—´ï¼Œä¸‹ä¸€æ¬¡æ›´æ–°å°†è®¡ç®—æ–°çš„äº‹ä»¶æ—¶é—´
  currentEventTime = NoTimestamp;
  currentEventTransitionLane = NoLanes;
  
  const originalCallbackNode = root.callbackNode;
  // å¤„ç† passive effectï¼ˆå³è§¦å‘ useEffect çš„åˆ›å»ºã€é”€æ¯å‡½æ•°åŠå…¶ä»–åŒæ­¥ä»»åŠ¡ï¼‰
  const didFlushPassiveEffects = flushPassiveEffects();
  if (didFlushPassiveEffects) {
    if (root.callbackNode !== originalCallbackNode) {
      return null;
    } else {
      // Current task was not canceled. Continue.
    }
  }

  // è·å–ä¸‹ä¸€ä¸ªè¦å¤„ç†çš„ lanes
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  // æ°¸è¿œä¸ä¼šæ‰§è¡Œ
  if (lanes === NoLanes) {
    return null;
  }

  // æ˜¯å¦å¼€å¯æ—¶é—´åˆ†ç‰‡
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);

  // æ„å»º fiber æ ‘
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);

  // æ£€æŸ¥é€€å‡ºçŠ¶æ€
  if (exitStatus !== RootInProgress) {
    // ...æ ¹æ® exitStatus åšä¸€äº›å¼‚å¸¸å¤„ç†ä»£ç çœç•¥
    
    // æ¸²æŸ“æœªå®Œæˆ æŒ‚èµ·
    if (exitStatus === RootDidNotComplete) {
      markRootSuspended(root, lanes);
    } else {
      // æ¸²æŸ“å®Œæˆ
      const renderWasConcurrent = !includesBlockingLane(root, lanes);
      const finishedWork: Fiber = (root.current.alternate: any);
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(finishedWork) // åˆ¤æ–­ store æ˜¯å¦ä¸€è‡´
      ) {
        // A store was mutated in an interleaved event. Render again,
        // synchronously, to block further mutations.
        exitStatus = renderRootSync(root, lanes);
        // ...æ ¹æ® exitStatus åšä¸€äº›å¼‚å¸¸å¤„ç†ä»£ç çœç•¥
      }

      // We now have a consistent tree. The next step is either to commit it,
      // or, if something suspended, wait to commit it after a timeout.
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;

      // å®Œæˆå¹¶å‘æ¸²æŸ“çš„åç»­å¤„ç†ï¼ˆå³è¿›å…¥ commit é˜¶æ®µï¼‰
      finishConcurrentRender(root, exitStatus, lanes);
    }
  }

  // é€€å‡ºå‰å†æ¬¡æ£€æµ‹æ˜¯å¦æœ‰å…¶ä»–æ›´æ–°
  ensureRootIsScheduled(root, now());

  // * åˆ¤æ–­ callbackNode æ˜¯å¦å’Œç¼“å­˜å€¼ä¸€è‡´ï¼Œæ¥ç¡®å®šæ˜¯å¦æ˜¯è¢«æ‰“æ–­çš„ä»»åŠ¡
  if (root.callbackNode === originalCallbackNode) {
    // * æ¸²æŸ“è¢«æ‰“æ–­ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„ performConcurrentWorkOnRoot ç­‰å¾…ä¸‹ä¸€æ¬¡è°ƒåº¦
    // * å³ Scheduler  workLoop ä¸­ task.callback æ‰§è¡Œå®Œè¿”å›çš„ continuationCallback
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
```

### render é˜¶æ®µ

`renderRootSync/renderRootConcurrent` åˆ†åˆ«æ˜¯åŒæ­¥æ„é€ ã€å¹¶å‘æ„é€  `workInProgressRoot` æ ‘çš„æ–¹æ³•ï¼Œæ¥ç€çœ‹

```js:renderRoot
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  // ä¿å­˜å½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡
  const prevExecutionContext = executionContext
  // è®¾ç½®å½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡ä¸º render ä¸Šä¸‹æ–‡
  executionContext |= RenderContext
  const prevDispatcher = pushDispatcher()

  // åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºæ–°çš„ workInProgressRoot æ ‘
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // ... éƒ¨åˆ†ä»£ç çœç•¥
    // åˆ›å»º workInProgressRoot æ ‘
    prepareFreshStack(root, lanes)
  }

  if (enableSchedulingProfiler) {
    markRenderStarted(lanes)
  }

  /**
   * å¾ªç¯æ¡ä»¶ä¸º true
   * åªæœ‰æ­£å¸¸æ‰§è¡Œå®Œ workLoopSync æ‰ä¼š break
   * å¦‚æœ workLoopSync æŠ›å‡ºå¼‚å¸¸ï¼Œä¼šè¢« handleError æ•è·ï¼Œç„¶åç»§ç»­å¾ªç¯ï¼Œç›´åˆ°æ­£å¸¸æ‰§è¡Œå®Œæ¯•
   */
  do {
    try {
      workLoopSync()
      break
    } catch (thrownValue) {
      handleError(root, thrownValue)
    }
  } while (true)

  resetContextDependencies()

  // å°†æ‰§è¡Œä¸Šä¸‹æ–‡ä¿®æ”¹ä¸ºä¹‹å‰çš„ä¸Šä¸‹æ–‡
  executionContext = prevExecutionContext
  popDispatcher(prevDispatcher)

  // è®¾ç½® workInProgressRoot ä¸º nullï¼Œè¡¨ç¤ºæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„æ¸²æŸ“
  workInProgressRoot = null
  workInProgressRootRenderLanes = NoLanes

  return workInProgressRootExitStatus
}
```
```js:renderRootConcurrent
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext
  executionContext |= RenderContext
  const prevDispatcher = pushDispatcher()

  // åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºæ–°çš„ workInProgressRoot æ ‘
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {

    resetRenderTimer()
    prepareFreshStack(root, lanes)
  }

  if (enableSchedulingProfiler) {
    markRenderStarted(lanes)
  }

  /**
   * å¾ªç¯æ¡ä»¶ä¸º true
   * åªæœ‰æ­£å¸¸æ‰§è¡Œå®Œ workLoopConcurrent æ‰ä¼š break
   * å¦‚æœ workLoopConcurrent æŠ›å‡ºå¼‚å¸¸ï¼Œä¼šè¢« handleError æ•è·ï¼Œç„¶åç»§ç»­å¾ªç¯ï¼Œç›´åˆ°æ­£å¸¸æ‰§è¡Œå®Œæ¯•
   */
  do {
    try {
      workLoopConcurrent()
      break
    } catch (thrownValue) {
      handleError(root, thrownValue)
    }
  } while (true)

  resetContextDependencies()

  popDispatcher(prevDispatcher)
  executionContext = prevExecutionContext

  // Check if the tree has completed.
  if (workInProgress !== null) {
    // Still work remaining.
    if (enableSchedulingProfiler) {
      markRenderYielded()
    }
    return RootInProgress
  } else {
    // Completed the tree.
    if (enableSchedulingProfiler) {
      markRenderStopped()
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null
    workInProgressRootRenderLanes = NoLanes

    // Return the final exit status.
    return workInProgressRootExitStatus
  }
}
```

`workLoop`ï¼Œæ„é€  Fiber æ ‘çš„å¾ªç¯

```js:workLoop
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```
`shouldYield`ï¼š`Scheduler.shouldYieldToHost`ï¼Œè¯¥å‡½æ•°ä¼šåˆ¤æ–­å½“å‰æ˜¯å¦æœ‰å‰©ä½™æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰å‰©ä½™æ—¶é—´ï¼Œå°±ä¼šè¿”å› `true` è¡¨ç¤ºéœ€è¦ä¸­æ–­å½“å‰ä»»åŠ¡ã€‚

```js:performUnitOfWork
function performUnitOfWork(unitOfWork: Fiber): void {
  // unitOfWork å³ä¼ å…¥çš„ workInProgress
  const current = unitOfWork.alternate // åŒç¼“å†²æ¶æ„

  let next
  // ... éƒ¨åˆ†ä»£ç çœç•¥
  // è°ƒç”¨ beginWork å‡½æ•°ï¼Œè¿›å…¥ â€œé€’â€ é˜¶æ®µ
  next = beginWork(current, unitOfWork, subtreeRenderLanes)

  // æ”¶é›† props
  unitOfWork.memoizedProps = unitOfWork.pendingProps

  // å½“ next ä¸º null æ—¶ï¼Œè¡¨ç¤ºå½“å‰ workInProgress æ²¡æœ‰å­èŠ‚ç‚¹
  if (next === null) {
    // è°ƒç”¨ completeUnitOfWork å‡½æ•°ï¼Œè¿›å…¥ â€œå½’â€ é˜¶æ®µ
    completeUnitOfWork(unitOfWork)
  } else {
    // æ›´æ–° workInProgress æŒ‡é’ˆä¸º next ï¼ˆå³å­ Fiber èŠ‚ç‚¹ï¼‰
    workInProgress = next
  }

  ReactCurrentOwner.current = null
}
```

- `beginWork` é€’é˜¶æ®µï¼Œä» rootFiber å¼€å§‹æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ ¹æ®ä¼ å…¥çš„ Fiber èŠ‚ç‚¹åˆ›å»ºå­èŠ‚ç‚¹ï¼Œå¹¶ä¸”æŠŠè¿™ä¸¤ä¸ªèŠ‚ç‚¹è¿æ¥èµ·æ¥ã€‚
- `completeUnitOfWork -> completeWork` å½’é˜¶æ®µï¼ŒcompleteWork æ‰§è¡Œå®Œå¦‚æœå­˜åœ¨å…„å¼ŸèŠ‚ç‚¹ï¼Œè¿›å…¥å…„å¼ŸèŠ‚ç‚¹çš„é€’é˜¶æ®µï¼Œå¦åˆ™è¿›å…¥çˆ¶èŠ‚ç‚¹çš„å½’é˜¶æ®µã€‚

### commit é˜¶æ®µ

![commitRoot](/static/images/react/commitRoot.png)

## è°ƒåº¦è¿‡ç¨‹

åˆ°ç›®å‰ï¼Œä¸€ä¸ªå¤§ä½“çš„ä»è¾“å…¥åˆ°è¾“å‡ºçš„æµç¨‹ï¼Œç®—æ˜¯ææ¸…æ¥šäº†ï¼Œæœ€åæ¥çœ‹çœ‹å·§å¦™çš„è°ƒåº¦æœºåˆ¶ã€‚

![scheduler](/static/images/react/scheduler.png)

### åˆ›å»ºä»»åŠ¡

è¿›å…¥è°ƒåº¦çš„å…¥å£æ˜¯ `unstable_scheduleCallback` è¿™ä¸ªæ–¹æ³•ï¼š

```js:unstable_scheduleCallback
// çœç•¥éƒ¨åˆ†æ— å…³ä»£ç 
function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = getCurrentTime();

  var startTime;
  if (typeof options === 'object' && options !== null) {
    // é€šè¿‡ options è®¾ç½®å»¶è¿Ÿ
  } else {
    startTime = currentTime;
  }

  // æ ¹æ®ä¼˜å…ˆçº§ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  var expirationTime = startTime + timeout;
  
  // åˆ›å»ºæ–°ä»»åŠ¡
  var newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };

  if (startTime > currentTime) {
    // çœç•¥ï¼Œå»¶è¿Ÿ taskï¼Œæ”¾å…¥ timerQueue
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }
    // Schedule a host callback, if needed. If we're already performing work,
    // wait until the next time we yield.
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```
```js:requestHostCallback
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    // æ ¹æ®ç¯å¢ƒå’Œå…¼å®¹æ€§åˆ†åˆ«ä½¿ç”¨ setImmediate/MessageChannel/setTimeout å‘é€æ¶ˆæ¯
    schedulePerformWorkUntilDeadline(); 
  }
}
```

### æ¶ˆè´¹ä»»åŠ¡

```js:performWorkUntilDeadline
const performWorkUntilDeadline = () => {
  // scheduledHostCallback æ˜¯åœ¨ requestHostCallback ç¼“å­˜çš„ flushWork æ¶ˆè´¹ä»»åŠ¡å‡½æ•°
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    // Keep track of the start time so we can measure how long the main thread
    // has been blocked.
    startTime = currentTime;
    const hasTimeRemaining = true;

    let hasMoreWork = true;
    try {
      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime); // flushWork è¢«æ‰“æ–­æ—¶ä¼šè¿”å› true
    } finally {
      if (hasMoreWork) {
        // If there's more work, schedule the next message event at the end
        // of the preceding one.
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      }
    }
  } else {
    isMessageLoopRunning = false;
  }
  // Yielding to the browser will give it a chance to paint, so we can
  // reset this.
  needsPaint = false;
};
```
```js:flushWork
// çœç•¥éƒ¨åˆ†ä»£ç 
function flushWork(hasTimeRemaining, initialTime) {
  // åšå¥½å…¨å±€æ ‡è®°, è¡¨ç¤ºç°åœ¨å·²ç»è¿›å…¥è°ƒåº¦é˜¶æ®µ
  isHostCallbackScheduled = false;
  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
    return workLoop(hasTimeRemaining, initialTime);
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}
```

ä»»åŠ¡é˜Ÿåˆ—æ¶ˆè´¹çš„å…³é”®å‡½æ•°å°±æ˜¯è¿™ä¸ª `workLoop`ï¼š

```js:workLoop
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime; // ä¿å­˜å½“å‰æ—¶é—´ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦è¿‡æœŸ
  advanceTimers(currentTime); // æ£€æŸ¥ timerQueueï¼ŒæŠŠä¸å†å»¶è¿Ÿçš„ä»»åŠ¡åŠ å…¥åˆ° taskQueue ä¸­
  currentTask = peek(taskQueue); // ä»å°é¡¶å †ä¸­è·å–å †é¡¶ä»»åŠ¡ï¼ˆæœ€ä¼˜å…ˆçš„ï¼‰

  while (currentTask !== null) {
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // currentTaskæ²¡æœ‰è¿‡æœŸ, ä½†æ˜¯æ‰§è¡Œæ—¶é—´è¶…è¿‡äº†é™åˆ¶(æ¯•ç«Ÿåªæœ‰5ms, shouldYieldToHost()è¿”å›true). åœæ­¢ç»§ç»­æ‰§è¡Œ, è®©å‡ºä¸»çº¿ç¨‹
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }
    const callback = currentTask.callback; // ä»»åŠ¡çš„å›è°ƒï¼Œå¯¹åº” performConcurrentWorkOnRoot
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      // æ‰§è¡Œå›è°ƒ
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      // åˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ´¾ç”Ÿå›è°ƒ
      if (typeof continuationCallback === 'function') {
        // äº§ç”Ÿäº†è¿ç»­å›è°ƒ(å¦‚fiberæ ‘å¤ªå¤§, å‡ºç°äº†ä¸­æ–­æ¸²æŸ“), currentTaskå’Œæ´¾ç”Ÿå›è°ƒä»ç„¶ä¿ç•™ç€
        currentTask.callback = continuationCallback;
      } else {
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }
      advanceTimers(currentTime); // å†æ¬¡æ£€æŸ¥ timerQueue æ˜¯å¦æœ‰ä»»åŠ¡åˆ°è¾¾æ‰§è¡Œæ—¶é—´
    } else {
      // å¦‚æœä»»åŠ¡è¢«å–æ¶ˆ(è¿™æ—¶currentTask.callback = null), å°†å…¶ç§»å‡ºé˜Ÿåˆ—
      pop(taskQueue);
    }
    currentTask = peek(taskQueue); // ç»§ç»­å–å‡ºä¸‹ä¸€ä¸ªä»»åŠ¡
  }
  // Return whether there's additional work
  if (currentTask !== null) {
    return true; // ä»»åŠ¡æ‰§è¡Œå®Œè¿”å› trueï¼Œ ç­‰å¾…è°ƒåº¦ä¸­å¿ƒä¸‹ä¸€æ¬¡è°ƒåº¦
  } else {
    // taskQueue æ‰§è¡Œå®Œæ¯•ï¼Œè¯·æ±‚ timerQueue
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

ä»£ç ä¸å¤šï¼Œä½† `æ—¶é—´åˆ‡ç‰‡` å’Œ `fiberæ ‘çš„å¯ä¸­æ–­æ¸²æŸ“` çš„ç²¾é«“ï¼Œéƒ½é›†ä¸­åœ¨è¿™ä¸ªå¾ªç¯å†…ã€‚

`æ—¶é—´åˆ‡ç‰‡`ï¼Œæ¯ä¸€æ¬¡ `while` å¾ªç¯çš„é€€å‡ºå°±æ˜¯ä¸€ä¸ªæ—¶é—´åˆ‡ç‰‡ï¼Œé€€å‡ºæ¡ä»¶æœ‰ä¸¤ç§æƒ…å†µï¼š
- `taskQueue` å…¨éƒ¨æ‰§è¡Œå®Œé€€å‡º
- ä»»åŠ¡è¶…æ—¶ï¼Œæ¯è½® `while` å¾ªç¯å¼€å§‹éƒ½ä¼šæ£€æµ‹ä»»åŠ¡æ‰§è¡Œæ—¶é—´æ˜¯å¦ä¼šè¶…æ—¶ï¼Œå¦‚æœè¶…æ—¶å°±ç«‹å³é€€å‡ºï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡è°ƒåº¦

`fiberæ ‘çš„å¯ä¸­æ–­æ¸²æŸ“`ï¼Œè¿˜è®°å¾— `workLoopConcurrent` çš„ while å¾ªç¯æ¡ä»¶: `workInProgress !== null && !shouldYield()`ï¼Œæ¯æ„é€ ä¸€ä¸ªå•å…ƒï¼Œå°±ä¼šå»æ£€æµ‹ä¸€ä¸‹æ˜¯å¦è¶…æ—¶ï¼Œ
å¦‚é‡è¶…æ—¶å°±é€€å‡º `fiberæ ‘æ„é€ å¾ªç¯`, å¹¶è¿”å›ä¸€ä¸ªæ–°çš„å›è°ƒå‡½æ•°(`å°±æ˜¯æ­¤å¤„çš„ continuationCallback`)å¹¶ç­‰å¾…ä¸‹ä¸€æ¬¡å›è°ƒç»§ç»­æœªå®Œæˆçš„fiberæ ‘æ„é€ 

{/* ## Hook */}

---

## æ€»ç»“

çº¸ä¸Šå¾—æ¥ç»ˆè§‰æµ…ï¼Œç»çŸ¥æ­¤äº‹è¦èº¬è¡Œã€‚è€è€å®å®è°ƒè¯•ä¸€éæºç ï¼Œæ¯”çœ‹å¤šå°‘æ–‡ç« éƒ½å—ç›Šçš„å¤šã€‚æœ¬æ–‡ä¹Ÿåªæ˜¯è®°å½•äº†å¤§æ¦‚å¾— React è¿è¡Œæµç¨‹ï¼Œä¸€äº›ç»†èŠ‚å°±ä¸è¿‡å¤šèµ˜è¿°äº†ã€‚

## æ¨èåšæ–‡

- [dan abramov çš„åšå®¢](https://overreacted.io/)
- [React æŠ€æœ¯æ­ç§˜](https://react.iamkasong.com/)
- [å›¾è§£ React](https://7km.top/)

