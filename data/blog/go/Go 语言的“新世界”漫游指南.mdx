---
title: '你好，Gopher！一份来自 Go 语言的“新世界”漫游指南'
summary: '这是一次前端开发者对Go语言的探索之旅。让我们一起踏上这段旅程，发现Go语言的魅力所在！'
date: '2025-07-07'
tags: ['go']
draft: true
---

> _一位前端er的Go语言探索之旅_

---

# 前言

本文非入门教程，非技术文档，非专业gopher编写（励志成为!），仅仅是一次前端开发者对Go语言的探索之旅。记录下一个月以来个人学习中认为较为重要‼️或者有趣🤔的部分。Let's go!

# 类型

Go语言的类型系统与JavaScript（JS）有很大不同。**Go语言是一种静态类型语言，而JS是动态类型语言**。这意味着在Go中，变量的类型在编译时就确定了(值还是在运行时确定的)，而在JS中，变量的类型可以在运行时改变。

强类型的语言，类型系统是非常非常之重要‼️，务必理解透彻。

## 基本类型

与JS相比，go语言的基本类型很简单就三种，数字、布尔和字符串。然而却也有大不同：

- **数字**：Go语言的数字类型足足有15种～。并且与JS的number不同，Go语言的数字类型是强类型的，不能自动转换。
- **布尔**：Go语言的布尔类型只有两个值：true和false。与JS的布尔类型相似，但Go语言不允许将非布尔值隐式转换为布尔值。
- **字符串**：Go语言的字符串是不可变的，与JS的字符串相似。但go语言字符串的操作依赖标准库`strings`，如`strings.Contains()`、`strings.Split()`等。
    - `len(string)`，返回字符串的字节长度，而不是字符数。
    - `utf8.RuneCountInString(string)`，返回字符数

## 组合类型

组合类型一共有以下 6 种：

- 容器类型
    - 数组类型
    - 切片类型
    - 映射类型
- 指针类型
- 结构体类型
- 接口类型
- 通道类型
- 函数类型

加上 `unsafe.Pointer` 类型，Go 语言中总共有 26 个类型种类。

#### 类型是否可比较

Go语言中，类型是否可比较取决于其底层类型。以下是一些规则：

- **不可比较类型**：包括切片、映射和函数类型。以及字段为不可比较类型的结构体和元素为不可比较类型的数组。
- 其他都为可比较类型

### 指针

> 因为go语言中所有的赋值都是**值复制**，所以指针是非常重要的概念，比如给函数传参。

指针存储的是**内存地址的起始地址**，一般用十六进制表示。

- `*T`类型表示基类型为 T 的指针类型
- `&T`类型表示 T 的指针，`*`用于解引用获取指针指向的值。

`&T` 和 `new(T)`的区别：

- `&val`：获取 val 的地址，val 必须是一个已存在的变量。
- `new(T)`：*分配内存*并返回 T 的指针，T 必须是一个类型而不是变量。

#### 值是否可寻址

在Go语言中，只有可寻址的值才能取地址。以下是一些规则：

- **变量、切片、指针解引用、可寻址的结构体的字段、可寻址的数组元素**，都是可寻址的。
- **常量、字面量、映射元素**、包级函数、方法(用作函数值)、临时值不可寻址。

> `&T{}` 在Go里是一个语法糖，它是 `tmp := T{}; (&tmp)` 的简写形式。  
> 所以&T{}是合法的并不代表字面量T{}是可寻址的

```go
type T struct {
    a int
}
_ = T{a: 1}     // 字面量不可寻址
_ = &T{a: 1}    // 合法，可取地址（但实际上是语法糖）
_ = &T{a: 1}.a  // 非法，字面量不可寻址, error
```

> 映射元素不能取地址是因为go的映射使用哈希表实现，同时为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段，**映射中的元素的地址会因为各种原因而改变**!  
> 切片元素总是可寻址的，因为切片是一个引用类型，它的底层数组是连续的内存段。

### 结构体

- `(*struct_val).prop` 可以简写为 `struct_val.prop`，会自动解引用。
- 结构体值互相转换，当值的类型的底层类型相同时(不用考虑tag)，可以强转；当底层类型相同，并且其中一个为无名类型，可以隐式转换。
- 结构体内嵌类型可以简化访问方式。内嵌结构体和内嵌结构体指针，对应部分在初始化的时候略有不同。

```go
func main() {
	type Person struct {
		Name string
	}
	type Man struct {
		Person // 内嵌结构体
		Age    int
	}

	var m Man
	m.Name = "Bob" // It's ok
	m.Age = 25

	fmt.Printf("m: %v\n", m)

	type ManWithPointer struct {
		*Person // 内嵌结构体指针
		Age     int
	}
	var m2 ManWithPointer
	m2.Person = &Person{Name: "Alice"} // ‼️需要先初始化指针
	m2.Age = 30                        // It's ok
	m2.Name = "name"                   // 没有初始化指针部分的话，这里会 panic

	fmt.Printf("m2: %v\n", m2)
}
```

### 接口

当一个类型实现了接口中的所有方法，则该类型就实现了这个接口。接口是Go语言中非常重要的概念，它允许不同类型之间进行多态操作。

接口值包括2个部分（动态类型、动态值）

```go
type Animal interface {
    Speak() string
}
type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}
type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}
func main()  {
    var a Animal // 接口类型变量---接口值 - 动态类型为 nil，动态值为 nil
    fmt.Println(a) // 输出: <nil> 零值接口值
    a = Dog{}    // 动态类型为 Dog，动态值为 Dog{}
    fmt.Println(a.Speak()) // 输出: Woof!

    a = Cat{}    // 动态类型为 Cat，动态值为 Cat{}
    fmt.Println(a.Speak()) // 输出: Meow!

    var b *Dog // 指针类型为 *Dog
	a = b      // 接口包裹了指针类型，动态类型为 *Dog，动态值为 nil
	fmt.Println(a == nil) // false, 因为接口值没有满足动态类型和动态值都为 nil
}
```

## 底层类型

- 类型定义

    ```go
    type A int8
    var a A = 1

    var c int8
    c = a
    // error, A 和 int8 是不同的类型，
    // 但他们共享了底层类型 int8, 可以显示转换 c = int8(a)
    fmt.Println(c)
    ```

- 类型别名

    ```go
     type A = int8
     var a A = 1

     var c int8 = 1
     c = a
     // OK 因为 A 就是 int8
     // 但请注意，类型别名并不是具名类型，也不是无名类型，它只是原类型的别称
    ```

### 底层类型的追溯规则：

> “在溯源过程中，当遇到一个内置类型或者无名类型时，溯源结束。”

```go
// 这三个类型的底层类型均为内置类型int。
type (
   MyInt int
   Age   MyInt
)

// 下面这三个新声明的类型的底层类型各不相同。
type (
   // 这三个源类型都是无名类型，回溯终止
   IntSlice   []int   // 底层类型为[]int
   MyIntSlice []MyInt // 底层类型为[]MyInt
   AgeSlice   []Age   // 底层类型为[]Age
)

// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
type Ages AgeSlice // AgeSlice是一个具名类型，继续回溯到[]Age
```

---

# 其他

## uint、int、uintptr

大小取决于操作系统的位数，32位系统为4字节，64位系统为8字节。

- **uint**：无符号整数类型，取值范围从0到2^n-1（n为位数）。
- **int**：有符号整数类型，取值范围从-2^(n-1)到2^(n-1)-1。
- **uintptr**：无符号整数类型，用于存储指针的整数表示。它的大小与指针的大小相同。

> 可以通过 `32 << (^uint(0) >> 63) // 64 or 32` 来判断是32位还是64位系统。

## 位运算的不同

1. 与JS的位运算符不同，Go语言的位运算符是强类型的，不能直接对非整数类型进行位运算。
2. Go语言的位运算符比较特殊的是 `^`，它作为一元运算符使用时表示按位取反，与JS的`~`类似；作为二元运算符使用时仍表示按位异或。
3. Go语言内置了清位运算符 `&^`，用于清除左侧对应右侧二进制为1的位置为0，`A &^ B` 等价于 `A & ^B`。这在JS中没有直接对应的运算符。
4. Go语言没有`>>>`（无符号右移）运算符，只有`>>`（有符号右移）运算符。因为Go有无符号的数字类型。
5. Go中，**移位运算符的优先级与乘法/除法相同**，高于加法/减法。而 JS 中，移位运算符的优先级低于加法/减法。
6. Go中**移位操作数必须是整数**，并且受**移位计数为常量还是变量**的影响。**常量在编译时就确定了值，而变量在编译时只能确定类型，运行时才确定值。**

    ```Go
    const n = 2             // n 是一个常量
    var m uint = 2          // m 是一个变量
    var _ float64 = 1 << n. // 等价于 var _ = float64(4)
    var _ float64 = 1 << m  // 等价于 var _ = float64(1) << m, error报错 左侧必须是整数类型

    // 另外一个例子
    const n = uint(8)
    var m = uint(8)

    var a byte = 1 << n / 128
    var b byte = 1 << m / 128

    fmt.Println(a) // 2  等价于byte(2)
    fmt.Println(b) // 0 // byte(1) << m / 128 = 0
    // 因为 1 << m 的结果是 uint(256)，而 byte 的最大值是 255，所以会发生溢出，导致结果为 0。
    ```

> 其他位运算基础知识可以看这里 [js的位操作](https://www.twotwoba.site/blog/algorithm/bit-operation)

## i++，i--

Go语言中只有 `i++` 和 `i--` 这两种自增自减操作符，没有 `++i` 和 `--i`。**并且没有返回值，不能当作表达式使用！**

```Go
func main() {
    i := 0
    i++
    fmt.Println(i++) // 1
    i--
    fmt.Println(i--) // 0
}
```
